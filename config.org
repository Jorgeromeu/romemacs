#+TITLE: Emacs Config
#+PROPERTY:header-args :tangle ~/.emacs.d/init.el

* =package.el= and =use-package= setup

Setting up package sources as well as =use-package=. This makes further package installations very easy.

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

;; Initialize use-package on non-Linux platforms
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

* Basic Settings
** Disable GUI elements

Remove GUI elements and startup screen.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)

(scroll-bar-mode 0)
(tool-bar-mode 0)
(tooltip-mode 0)
(set-fringe-mode 10)
(menu-bar-mode 0)
#+END_SRC

Show y/n text prompts prompts instead of GUI popups

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil)
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Disable blinking cursor

#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

Make frame title empty by default

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "")
#+END_SRC

** Terminal mode

I use emacs on the terminal (mosty) so i need mouse support

#+BEGIN_SRC emacs-lisp
(xterm-mouse-mode 1)
#+END_SRC

** Fonts

I am using [[https:github.com/gaplo916/Ligatured-Hack][ligatured Hack]] as my font. This is a fork of Hack but with
ligatures. I use Hack because it is one of the only monospaced fonts I
know of that looks good in code and also for text.

#+BEGIN_SRC emacs-lisp
(defun rom/fonts-setup ()
  (set-frame-font "Hack FC Ligatured-11"))

(rom/fonts-setup)
(add-hook 'server-after-make-frame-hook 'rom/fonts-setup)
#+END_SRC
#+RESULTS:
| doom-modeline-refresh-font-width-cache | rom/fonts-setup |

I use [[https:github.com/mickeynp/ligature.el][ligature.el]] to get typographic ligatures. I dont enable all of
them but rather limit myself to basic arrows and operators. I find
some of the ligatures such as www distracting and unnecesary.

#+BEGIN_SRC emacs-lisp
(use-package ligature
  :load-path "~/.emacs.d/ligature.el"
  :config

  (ligature-set-ligatures 't '("<-" "->" "<->" "-->" "<--" "=>" "<==" "==>" "<=>"
                               ":=" "=!=" "!=" "^=" ".="
                               ;; ">>" "<<" ">>>" "<<<"
                               "<=" ">=" "<>"
                               ;; "--" "++"
                               "<!--"
                               ))


  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+END_SRC

#+RESULTS:
: t

** Quality of life settings

Disable alarms and beeping

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

Make =Esc= quit prompts. (Makes escape work like =C-g=).

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC

Use system clipboard

#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard t)
(setq mouse-yank-at-point t)
#+END_SRC

Confirm before killing emacs

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

Trust all themes

#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)
#+END_SRC

Increase undo limits

#+BEGIN_SRC emacs-lisp
(setq undo-limit 6710886400)
(setq undo-strong-limit 100663296)
(setq undo-outer-limit 1006632960)
#+END_SRC

When I do =C-x k= immediately close the current buffer, dont ask for
which one to close.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

Clean up trailing lines and whitespace when writing to a file

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

Increase garbage collection threshold (too low for modern standards)
as well as the process reading threshold

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
(setq read-process-output-max (* 1024 1024))
#+END_SRC

Use system trash when deleting stuff

#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC

Disable line wrapping by default.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

Indicate empty lines

#+BEGIN_SRC emacs-lisp
(setq-default indicate-empty-lines t)
#+END_SRC

Save file positions

#+BEGIN_SRC emacs-lisp
(save-place-mode t)
#+END_SRC

** File backups

Dont litter my filesystem with lockfiles and autosaves.

#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil
      auto-save-default nil

      ;; do make backups but put them in a specific directory
      make-backup-files t
      backup-directory-alist '(("" . "~/.emacs.d/saves")))
#+END_SRC

** Scrolling

Scrolling in emacs is kind of a mess. Nonetheles I think i have found the settings which seem to work best.

#+BEGIN_SRC emacs-lisp
(setq scroll-step 1

      ;; vim style keyboard scrolling with a scrollof of 3
      scroll-margin 3
      scroll-conservatively 1000

      ;; mouse scroll by one line and by 2 when holding shift
      mouse-wheel-scroll-amount '(1 ((shift) . 2))
      mouse-wheel-progressive-speed nil
      mouse-wheel-follow-mouse 't
      mouse-wheel-inhibit-click-time nil

      ;; horizontal scrolliing for long lines
      hscroll-step 2
      hscroll-margin 3

      ;; enable scrolling horizontally with mouse
      mouse-wheel-flip-direction nil
      mouse-wheel-tilt-scroll nil)
#+END_SRC

** Parentheses and delimiters

I use the =rainbow-delimiters= package to color matching parens. Also the default =electric-pair-mode= to automatically insert matching pairs and =show-paren-mode= to highlight the matching paren when the cursor is over one.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode)
  (LaTeX-mode . rainbow-delimiters-mode))

(electric-pair-mode 1)
(show-paren-mode 1)

;; Don't blink, it's too distracting.
(setq blink-matching-paren nil)
(setq show-paren-delay 0.0)
(setq show-paren-highlight-openparen t)
(setq show-paren-when-point-inside-paren t)

#+END_SRC

#+RESULTS:
: t

** Line numbers

Automatically display line numbers in programming modes:

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode 1)))
#+END_SRC

** Prettify Symbols Mode

=prettify-symbols-mode= replaces all instances of certain strings with a specific character according to the alist: =prettify-symbols-alist= for the current major mode. The global prettify symbols mode enables the mode in all buffers and re-loads the alist for each major mode (this way each mode can implement a list of symbols to replace).

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode 1)
#+END_SRC

** Indentation

Dont use tabs.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
              indent-tabs-mode nil)
#+END_SRC

** Auto reload

Auto reload a file when it changes on disk

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

* Aesthetics

Doom-Nord theme is my theme of choice.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  :config
  (load-theme 'doom-nord t)
  (doom-themes-org-config))
#+END_SRC

#+RESULTS:
: t

I use Doom modeline since it is fast enough and much nicer looking than the default.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :config
  (setq all-the-icons-scale-factor 1.0))

(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :custom
  (doom-modeline-height 25)
  (doom-modeline-icon t)
  (doom-modeline-major-mode-color-icon t)
  (doom-modeline-buffer-file-name-style 'truncate-from-project)
  (doom-modeline-buffer-state-icon t)
  (doom-modeline-buffer-modification-icon nil)
  (doom-modeline-minor-modes nil)
  (doom-modeline-indent-info nil)
  (doom-modeline-checker-simple-format t)
  (doom-modeline-vcs-max-length 12)
  (doom-modeline-workspace-name t)
  (doom-modeline-env-version t)
  (doom-modeline-lsp t)
  (doom-modeline-buffer-encoding nil)
  :config
  (line-number-mode 1)
  (column-number-mode 1))
#+END_SRC

* Keybindings
** Evil mode

Evil mode provides vim emulation. This is a must-have feature for me.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-i-jump nil)
  (setq evil-undo-system 'undo-fu)
  :config
  (evil-mode 1)
  (setq evil-search-module 'evil-search)
  (setq evil-echo-state nil)

  ;; Use visual line j/k motions
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  (evil-set-initial-state 'messages-buffer-mode 'normal))
#+END_SRC

#+RESULTS:
: t

The k package overrides some default bindings to make them vim-like.

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+END_SRC

=evil-surround= extends evil mode to include vim-surround like bindings

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :demand t
  :config
  (global-evil-surround-mode 1))
#+END_SRC

Likewise =evil-commentary= adds evil-commentary bindings, specifically =gc l= to comment a line

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :config
  (evil-commentary-mode 1))
#+END_SRC

I use the =key-chord= package to map 'jj' in evil insert state to =Esc=

#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :config
  (setq key-chord-two-keys-delay 0.5)
  (key-chord-define evil-insert-state-map "jj" 'evil-normal-state)
  (key-chord-mode 1))
#+END_SRC

** General Bindings

I use space as a leader key

#+BEGIN_SRC emacs-lisp
(evil-set-leader 'normal (kbd "<SPC>"))
#+END_SRC

Some general purpose leader key bindings

#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal 'global (kbd "<leader>k") 'kill-this-buffer)
(evil-define-key 'normal 'global (kbd "<leader>f") 'counsel-find-file)
(evil-define-key 'normal 'global (kbd "<leader>RET") 'bookmark-jump)
(evil-define-key 'normal 'global (kbd "<leader>d") 'dired-jump)
(evil-define-key 'normal 'global (kbd "<leader>r") 'counsel-recentf)
(evil-define-key 'normal 'global (kbd "<leader>j") 'counsel-imenu)
(evil-define-key 'normal 'global (kbd "<leader>l") 'counsel-locate)
(evil-define-key 'normal 'global (kbd "<leader>-") 'hl-line-mode)
#+END_SRC

Also some standard Ctrl bindings are added:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)

(evil-define-key 'visual 'global (kbd "C-c") 'rom/copy-to-clipboard)
(evil-define-key 'insert 'global (kbd "C-v") 'rom/paste-from-clipboard)
#+END_SRC

  #+RESULTS:

* Core packages
** Ivy, Counsel and Swiper

I use IVY to intelligently show suggestions for all minibuffer commands

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-kill-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         ("C-o" . ivy-switch-buffer-other-window)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (setq ivy-use-virtual-buffers nil)
  (setq enable-recursive-minibuffers nil)
  (ivy-mode 1))
#+END_SRC

Ivy-rich adds some extra columns to ivy to provide more information
(docstring, binding, ...).

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :diminish
  :init
  (ivy-rich-mode 1))
#+END_SRC

Counsel provides replacements to some command such as =find-file= and
=switch-buffer= and so on which integrate nicely with ivy.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :diminish
  :config
  (setq counsel-switch-buffer-preview-virtual-buffers nil)
  (counsel-mode 1))
#+END_SRC

** Company

Company mode provides a general purpose code completion interface
which can be used by LSP and other backends.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :init
  ;; enable company in programming modes
  (add-hook 'prog-mode-hook 'company-mode)
  :config

  ;; no delay, and start suggesting after just one character
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 1)

  )
#+END_SRC

#+RESULTS:
: t

** Eglot

Eglot is a LSP client for emacs. In my opinion it is much simpler than LSP mode

#+BEGIN_SRC emacs-lisp
(use-package eglot
  :defer t
  :ensure t)
#+END_SRC


** Projectile

Projectile provides a lot of commands for interacting with projects, such as:

- finding a file within a project
- compiling/running the project
- opening dired in the project root

  #+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode 1)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
  #+END_SRC

** Neotree

Provides a nice tree-directory viewer

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :config
  (setq neo-window-fixed-size nil)
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit)
#+END_SRC

** Projectile

Projectile provides a lot of commands for interacting with projects, such as:

- finding a file within a project
- compiling/running the project
- opening dired in the project root

  #+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer t
    :init
    (projectile-mode 1)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
  #+END_SRC

  #+RESULTS:
  : projectile-command-map

** Neotree

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :defer t
  :config
  (setq neo-window-fixed-size nil)
  (setq neo-theme (if (display-graphic-p)
                      'icons
                    'arrow)))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer t)
#+END_SRC

** Dired

Dired is emacs's built in file manager.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :commands (dired dired-jump)
  :custom ((dired-listing-switches "-agho --group-directories-first"))
  :hook (dired-mode . dired-omit-mode)
  :hook (dired-mode . dired-hide-details-mode)
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'top)
  (evil-collection-define-key 'normal 'dired-mode-map
    "h" 'dired-up-directory
    "l" 'dired-find-file))
#+END_SRC

Hide dotfiles and details by default, toggle them with '.'

#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :config
  ;; toggle hidden dotfiles with "."
  (evil-collection-define-key 'normal 'dired-mode-map
    "." 'dired-hide-dotfiles-mode))
#+END_SRC

Use icons in dired.

#+BEGIN_SRC emacs-lisp
; TODO Automatically enable in graphical mode
(use-package all-the-icons-dired
  :after all-the-icons)
#+END_SRC

#+RESULTS:
: t

Open files with specific extensions with specific programs. For
example I want all pngs to open with the gnome image viewer.

#+BEGIN_SRC emacs-lisp
(use-package dired-open
  :config
  (setq dired-open-extensions '(("png" . "eog")
                                ("jpg" . "eog")
                                ("svg" . "eog")
                                ("gif" . "eog")
                                ("mkv" . "mpv")
                                ("mp4" . "mpv")
                                ("pdf" . "evince"))))
#+END_SRC

Auto reload dired when a file/directory is added/deleted externally

#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

** xclip

I use linux and emacs in the terminal. This makes emacs copy-pastes be handled through xclip so I can use them outside of emacs.

#+BEGIN_SRC emacs-lisp
(use-package xclip
  :config
  (xclip-mode 1))
#+END_SRC

* Quality of life packages

These are the packages I can live with out but are still nice to have

** Undo-fu

Provides a standard undo system. I used to use undo-tree but this is faster and I never really used the visualization features.

#+BEGIN_SRC emacs-lisp
(use-package undo-fu)
#+END_SRC

** Origami

=origami-mode= allows you to fold sections of code. I use the bindings provided by evil mode

#+BEGIN_SRC emacs-lisp
(use-package origami
  :defer t
  :config
  (global-origami-mode 1)
  (push '(scala-mode . origami-c-style-parser) origami-parser-alist)
  (push '(java-mode . origami-c-style-parser) origami-parser-alist)
  (push '(rust-mode . origami-c-style-parser) origami-parser-alist)
  (push '(kotlin-mode . origami-c-style-parser) origami-parser-alist))
#+END_SRC

** Treesitter

Treesitter gives enhanced code highlighting based on the syntax tree rather than naive regex-matches

#+BEGIN_SRC emacs-lisp
(use-package tree-sitter)
(use-package tree-sitter-langs)

(global-tree-sitter-mode)
(add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
#+END_SRC

** Highlight TODO

Very simple, highlights TODO, FIXME, KLUDGE and other similar strings in code comments

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :custom-face
  (hl-todo ((t (:inherit hl-todo :italic t))))
  :hook ((prog-mode . hl-todo-mode)
         (yaml-mode . hl-todo-mode)))
#+END_SRC

** Helpful

Helpful replaces the standard help commands with more... helpful alternatives.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :commands (helpful-callable helpful-variable helpful-command helpful-key)
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))
#+END_SRC

** Uniquify

The built in package uniquify allows you to modify what should happen when you have buffers with the same name. I simply also include the directory name separated by a ":".

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :ensure nil
  :config
  (setq uniquify-buffer-name-style 'post-forward
        uniquify-separator ":"))
#+END_SRC

** Bookmarks

Save bookmarks file whenever a bookmark action takes place.

#+BEGIN_SRC emacs-lisp
(setq bookmark-save-flag 1)
#+END_SRC

** Recentf

Recentf is a built in package that keeps track of recently edited files

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :defer 10
  :config
  (setq recentf-max-saved-items 50)
  (setq recentf-auto-cleanup 'never)
  (recentf-mode t))
#+END_SRC

** Org Cliplink

Org cliplink makes it easy to automatically create a link to the sourece copied in the clipboard

#+BEGIN_SRC emacs-lisp
(use-package org-cliplink
  :defer t)
#+END_SRC

** All the icons

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :defer t)
#+END_SRC

* Major modes
** Scala

#+BEGIN_SRC emacs-lisp
(use-package scala-mode)
#+END_SRC

** Kotlin

#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode)
#+END_SRC

** Org Mode

#+BEGIN_SRC emacs-lisp
(use-package org
  :defer t
  :config
  (setq org-ellipsis " ▾"
        org-hide-emphasis-markers t
        org-edit-src-content-indentation 0
        org-highlight-latex-and-related '(latex)
        org-format-latex-options (plist-put org-format-latex-options :scale 1.50)
        org-indent-mode-turns-on-hiding-stars nil))
#+END_SRC

The =rom/org-mode-setup= function configures some org mode settings and runs when I enter an org buffer.

#+BEGIN_SRC emacs-lisp
(defun rom/org-mode-setup ()

  ;; header faces
  (set-face-attribute 'org-level-1 nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-2 nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-3 nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-4 nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-5 nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-6 nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-7 nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-8 nil :weight 'bold :height 1.0)

  ;; TODO and DONE faces
  (set-face-attribute 'org-done nil :weight 'bold :height 1.0 :slant 'normal)
  (set-face-attribute 'org-headline-done nil :weight 'bold :height 1.0)
  (set-face-attribute 'org-todo nil :weight 'bold :height 1.0 :slant 'normal)

  ;; custom prettify symbols alist
  (push '("#+TITLE: "        . "") prettify-symbols-alist)
  (push '("#+SUBTITLE: "     . "") prettify-symbols-alist)
  (push '("#+AUTHOR: "       . "-") prettify-symbols-alist)
  (push '(":PROPERTIES:"     . ":") prettify-symbols-alist)
  (push '("#+PROPERTY:"      . ":") prettify-symbols-alist)
  (push '("#+BEGIN_SRC"      . "λ") prettify-symbols-alist)
  (push '("#+END_SRC"        . "-") prettify-symbols-alist)
  (push '("#+RESULTS:"       . "»") prettify-symbols-alist)
  (push '(":end:"            . "-") prettify-symbols-alist)
  (push '(":results:"        . "-") prettify-symbols-alist)
  (push '("#+NAME:"          . "-") prettify-symbols-alist)
  (push '("#+BEGIN_EXAMPLE"  . "~") prettify-symbols-alist)
  (push '("#+END_EXAMPLE"    . "~") prettify-symbols-alist)
  (push '("#+BEGIN_VERBATIM" . "") prettify-symbols-alist)
  (push '("#+END_VERBATIM"   . "") prettify-symbols-alist)
  (push '("#+BEGIN_VERSE"    . "") prettify-symbols-alist)
  (push '("#+END_VERSE"      . "") prettify-symbols-alist)
  (push '("#+BEGIN_QUOTE"    . "") prettify-symbols-alist)
  (push '("#+END_QUOTE"      . "") prettify-symbols-alist)
  (push '("#+TBFLM:"         . "∫") prettify-symbols-alist)
  (push '("[X]"              . (?\[ (Br . Bl) ?✓ (Br . Bl) ?\])) prettify-symbols-alist)
  (push '("\\\\"             . "↩") prettify-symbols-alist)

  (visual-line-mode 1)
  (org-indent-mode 1))

(add-hook 'org-mode-hook 'rom/org-mode-setup)
#+END_SRC

*** Org Cliplink

#+BEGIN_SRC emacs-lisp
(use-package org-cliplink)
#+END_SRC

** YAML mode

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :defer t)
#+END_SRC

** LaTeX

Not a prog mode so I enable rainbow delimiters mode

#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :defer t)
#+END_SRC
#+RESULTS:

* Aliases

I use aliases for M-x commands which I use frequently, but not so frequently that mapping it to an obscure key combination makes sense.

#+BEGIN_SRC emacs-lisp
(defalias 'ln 'display-line-numbers-mode)
(defalias 'conceal 'prettify-symbols-mode)
(defalias 'cmp 'company-mode)
(defalias 'tshl 'tree-sitter-hl-mode)

(defalias 'nt 'neotree-toggle)
(defalias 'rb 'revert-buffer)
(defalias 'regex 'replace-regexp)
(defalias 'iregex 'query-replace-regexp)
                                        ; general
(defalias 'lt 'counsel-load-theme)
(defalias 'scroll 'scroll-bar-mode)
(defalias 'rename 'crux-rename-file-and-buffer)
(defalias 'errors 'flycheck-list-errors)
#+END_SRC

#+RESULTS:
: errors

* Buffer and Window Managment
** Buffer Switching

The functiom =rom/switch-buff= calls =counsel-switch-buffer= but excludes buffers that match certain regexps.

#+BEGIN_SRC emacs-lisp
(defun rom/switch-buff ()
  (interactive)
  (let ((ivy-ignore-buffers '("*help"
                              "*Messages*"
                              "*Warnings*"
                              "*lsp-log*"
                              "*Minibuff"
                              "*Calendar"
                              "*Org Agenda"
                              "*Backtrace"
                              "*Buffer List"
                              "*RE-Builder"
                              "*Bufler"
                              "*pyls"
                              "*Compile-log"
                              "magit-process"
                              "magit-diff"
                              "*ediff-"
                              "*Ediff Registry"
                              "*clangd")))

    (call-interactively 'counsel-switch-buffer)))

(evil-define-key 'normal 'global (kbd "<leader><SPC>") 'rom/switch-buff)
#+END_SRC

** Display buffer alist

I use a customized =display-buffer-alist=. This variable tells emacs how to display buffers based on their name. My layout is configured to work with three areas:

- *Main area* Used to display the documents/files I am editing. I can split normally
- *Bottom window* Used for shells, compilation outputs, ...
- *Side window* Used mainly for reference windows such as help/man pages (but also for other purposes)


#+BEGIN_SRC emacs-lisp
(setq display-buffer-alist `((,(rx "*" (or "help"
                                           "man"
                                           "WoMan"
                                           "bufler"
                                           "gud"))

                              ;; display help buffers at the right
                              (display-buffer-reuse-window display-buffer-in-side-window)
                              (side . right)
                              (window-width . 0.4))

                             (,(rx "*" (or "vterm"
                                           "terminal"
                                           "shell"
                                           "compilation"
                                           "maxima"
                                           "input"
                                           "Python"
                                           "KotlinREPL"
                                           "scala"
                                           "ielm"
                                           "TeX"
                                           "eldoc"
                                           "BackTrace"
                                           "Warnings"
                                           "Messages"
                                           "Flycheck errors"
                                           "Flymake diagnostics"
                                           ))

                              ;; display shell, compilation and error buffers at the bottom
                              (display-buffer-reuse-window display-buffer-in-side-window)
                              (side . bottom)
                              (window-width . 10))))
#+END_SRC
